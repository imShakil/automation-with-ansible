# EpicBook App Deployment using Terraform + Ansible

Automated deployment of the EpicBook Node.js application on AWS EC2 using Terraform for infrastructure provisioning and Ansible for application configuration.

## Architecture

- **Infrastructure**: AWS VPC, EC2 instance, RDS MySQL, Security Groups
- **Application**: Node.js EpicBook app with AWS RDS MySQL database
- **Web Server**: Nginx reverse proxy
- **Region**: ap-southeast-1 (Singapore)

## Prerequisites

- AWS CLI configured with appropriate credentials
- Terraform >= 1.0
- Ansible >= 2.9
- SSH key pair (`~/.ssh/id_rsa`)

## Quick Start

### 1. Deploy Infrastructure

```bash
cd terraform
terraform init
terraform plan
terraform apply -auto-approve
```

This creates:

- VPC with public/private subnets (10.0.0.0/16)
- EC2 instance (t2.micro, Amazon Linux 2023)
- RDS MySQL instance (db.t3.micro)
- Security groups (SSH, HTTP, HTTPS, MySQL)
- Auto-generates Ansible inventory

### 2. Deploy Application

```bash
cd ../ansible
ansible-playbook -i inventory.ini site.yaml
```

This configures:

- System packages (Node.js, MySQL client, Nginx)
- EpicBook application from GitHub
- Database connection to RDS MySQL
- Database schema and seed data
- Nginx reverse proxy
- Systemd services

## Configuration

### Terraform Variables

- `prefix`: Resource naming prefix (default: "epkbk")
- `instance_type`: EC2 instance type (default: "t2.micro")
- `ami_id`: Amazon Linux 2023 AMI
- `ssh_key_pair`: SSH key configuration

### Ansible Variables

- `project_repo_url`: https://github.com/pravinmishraaws/theepicbook
- `db_name`: bookstore
- `db_user`: theepicbook
- Application runs on port 8080, proxied via Nginx on port 80

## Access

After deployment, access the application at:

```sh
http://<EC2_PUBLIC_IP>
```

## Cleanup

```bash
cd terraform
terraform destroy
```

## File Structure

```sh
├── README.md
├── ansible
│   ├── ansible.cfg
│   ├── inventory.ini
│   ├── site.yaml
│   ├── inventories
│   │   └── inventory.ini
│   ├── roles
│   │   ├── app
│   │   │   ├── handlers
│   │   │   │   └── main.yaml
│   │   │   ├── tasks
│   │   │   │   └── main.yaml
│   │   │   └── templates
│   │   │       └── my.cnf.j2
│   │   ├── database
│   │   │   └── tasks
│   │   │       └── main.yaml
│   │   ├── epicbook
│   │   │   ├── handlers
│   │   │   │   └── main.yaml
│   │   │   ├── tasks
│   │   │   │   └── main.yaml
│   │   │   └── templates
│   │   │       ├── config.json.j2
│   │   │       └── epicbook.service.j2
│   │   └── nginx
│   │       ├── handlers
│   │       │   └── main.yaml
│   │       ├── tasks
│   │       │   └── main.yaml
│   │       └── templates
│   │           └── nginx.conf.j2
│   └── vars
│       ├── env.yml
│       └── vault.yml
└── terraform
    ├── backend.tf
    ├── main.tf
    ├── outputs.tf
    ├── provider.tf
    ├── variables.tf
    └── modules
        ├── instance
        │   ├── main.tf
        │   ├── outputs.tf
        │   └── variables.tf
        └── vpc
            ├── main.tf
            ├── outputs.tf
            └── variables.tf
```

## Project Structure Overview

### 🏗️ Terraform Directory (Infrastructure Layer)

#### Terraform Root Files

- **`main.tf`** - Primary infrastructure definitions (VPC, EC2, security groups)
- **`variables.tf`** - Input parameters (instance type, AMI ID, region)
- **`outputs.tf`** - Export values (public IP, instance ID) for Ansible
- **`provider.tf`** - AWS provider configuration and version constraints
- **`backend.tf`** - Remote state storage (S3 bucket, DynamoDB locking)

#### Modules (Reusable Components)

- **`modules/vpc/`** - Network infrastructure (VPC, subnets, internet gateway)
- **`modules/instance/`** - EC2 instance with security groups and key pairs

**Why modules?** Promotes reusability, testing, and maintainability across environments.

### 🔧 Ansible Directory (Configuration Layer)

#### Ansible Core Files

- **`ansible.cfg`** - Ansible behavior settings (SSH options, inventory path)
- **`site.yaml`** - Main playbook orchestrating all roles
- **`inventory.ini`** - Target hosts (auto-generated by Terraform)

#### Roles (Service Components)

Each role handles a specific service:

- **`app/`** - System packages and basic server setup
- **`database/`** - MySQL client and RDS connection setup
- **`epicbook/`** - Node.js application deployment
- **`nginx/`** - Web server and reverse proxy setup

#### Role Structure

- **`tasks/main.yaml`** - Execution steps (install, configure, start)
- **`handlers/main.yaml`** - Event-driven actions (restart services)
- **`templates/`** - Configuration file templates (Jinja2)

#### Variables

- **`vars/env.yml`** - Environment-specific settings
- **`vars/vault.yml`** - Encrypted secrets (database passwords)

### 🔄 Why This Structure?

#### Separation of Concerns

- **Terraform** = Infrastructure state management
- **Ansible** = Configuration and deployment

#### Scalability

- Modular design allows environment replication
- Role-based structure enables service reuse

#### Maintainability

- Clear file organization
- Template-driven configuration
- Version-controlled infrastructure

#### Security

- Encrypted secrets with Ansible Vault
- SSH key-based authentication
- Least privilege security groups

This structure follows DevOps best practices, making the deployment process repeatable, scalable, and maintainable across different environments.

## Ansible Lint Challenges

### Common Issues & Solutions

**Problem**: Ansible runs fine, but ansible-lint fails with strict rules

**Common Lint Errors**:

- `name[missing]`: Every task needs a descriptive name
- `yaml[line-length]`: Lines exceed 160 characters
- `risky-file-permissions`: File operations need explicit mode
- `package-latest`: Use specific versions instead of `state: latest`
- `command-instead-of-module`: Use dedicated modules over shell/command

**Quick Fixes**:

```yaml
# Bad
- yum: name=nginx state=latest

# Good
- name: Install nginx web server
  yum:
    name: nginx
    state: present
```

**Lint Configuration**:

Create `.ansible-lint` to customize rules:
```yaml
skip_list:
  - yaml[line-length]
  - name[casing]
```

**Pro Tips**:

- Run `ansible-lint --list-rules` to see all rules
- Use `ansible-lint --fix` for auto-corrections
- Start with basic rules, gradually enforce stricter ones
- Focus on security and maintainability rules first

Remember: ansible-lint enforces best practices that make your code more maintainable and secure in the long run, even if it feels restrictive initially.

## Deployment Workflow

### Step-by-Step Process

1. **Infrastructure Provisioning** (Terraform)
   ```bash
   cd terraform
   terraform init
   terraform validate
   terraform plan -out=tfplan
   terraform apply tfplan
   ```

2. **Inventory Generation** (Automated)
   - Terraform automatically creates `ansible/inventory.ini`
   - Contains EC2 public IP and SSH configuration

3. **Application Deployment** (Ansible)
   ```bash
   cd ../ansible
   ansible-playbook -i inventory.ini site.yaml --check  # Dry run
   ansible-playbook -i inventory.ini site.yaml
   ```

4. **Verification**
   ```bash
   # Test application endpoint
   curl http://<EC2_PUBLIC_IP>

   # Check service status
   ansible app -i inventory.ini -m shell -a "systemctl status epicbook nginx"
   ```

### Deployment Timeline

- **Terraform**: ~3-5 minutes (VPC, EC2, Security Groups)
- **Ansible**: ~8-12 minutes (Package installation, app setup)
- **Total**: ~15 minutes for complete deployment

## Troubleshooting Guide

### Common Issues

#### 1. SSH Connection Failures
```bash
# Problem: Permission denied (publickey)
# Solution: Verify SSH key permissions
chmod 600 ~/.ssh/id_rsa
ssh-add ~/.ssh/id_rsa
```

#### 2. Terraform State Lock
```bash
# Problem: State locked by another process
# Solution: Force unlock (use carefully)
terraform force-unlock <LOCK_ID>
```

#### 3. Ansible Task Failures
```bash
# Problem: Package installation fails
# Solution: Check connectivity and retry
ansible app -i inventory.ini -m ping
ansible-playbook -i inventory.ini site.yaml --limit failed_hosts
```

#### 4. Application Not Accessible
```bash
# Check security group rules
aws ec2 describe-security-groups --group-ids <SG_ID>

# Verify service status on target host
ssh ec2-user@<PUBLIC_IP> "sudo systemctl status epicbook nginx"
```

### Debug Commands

```bash
# Ansible verbose output
ansible-playbook -i inventory.ini site.yaml -vvv

# Terraform debug logging
export TF_LOG=DEBUG
terraform apply

# Check application logs
ssh ec2-user@<PUBLIC_IP> "sudo journalctl -u epicbook -f"
```

## Security Considerations

### Network Security
- VPC with private subnets for RDS database isolation
- Security groups with minimal required ports (22, 80, 443, 3306)
- RDS in private subnet with no direct internet access

### Application Security
- Ansible Vault for sensitive data encryption
- SSH key-based authentication only
- Regular security updates via package management

### Best Practices Implemented
- Least privilege access principles
- Encrypted secrets management
- Infrastructure as Code for audit trails
- Automated deployment reduces human error

## Performance Optimization

### Infrastructure Tuning
- **Instance Type**: t2.micro for development, consider t3.medium+ for production
- **Storage**: GP3 volumes for better IOPS performance
- **Networking**: Placement groups for multi-instance deployments

### Application Optimization
- **Nginx**: Gzip compression, static file caching
- **Node.js**: PM2 process manager for clustering
- **Database**: Connection pooling, query optimization

### Monitoring Setup
```bash
# CloudWatch agent installation
ansible app -i inventory.ini -m yum -a "name=amazon-cloudwatch-agent state=present"

# Application health checks
curl -f http://<PUBLIC_IP>/health || echo "Health check failed"
```

## Lessons Learned

### What Worked Well
1. **Modular Terraform Design**: Reusable VPC and instance modules
2. **Ansible Role Structure**: Clear separation of concerns
3. **Automated Inventory**: Seamless Terraform-to-Ansible handoff
4. **Template-Driven Config**: Jinja2 templates for environment flexibility

### Challenges Encountered
1. **Ansible Lint Compliance**: Required significant refactoring for best practices
2. **SSH Key Management**: Initial permission issues with key files
3. **Service Dependencies**: Ensuring proper startup order for database and app
4. **Network Timing**: Occasional delays in EC2 instance readiness

### Improvements for Production
1. **Multi-AZ RDS**: High availability database across availability zones
2. **Load Balancer**: Application Load Balancer for traffic distribution
3. **RDS Scaling**: Read replicas and automated scaling
4. **CI/CD Pipeline**: GitLab/GitHub Actions for automated deployments
5. **Monitoring**: CloudWatch, Prometheus, or DataDog integration
6. **Backup Strategy**: RDS automated backups and point-in-time recovery

### Cost Optimization

- **Spot Instances**: 70% cost reduction for non-critical environments
- **Reserved Instances**: Long-term cost savings for production
- **Auto Scaling**: Dynamic capacity based on demand
- **Resource Tagging**: Cost allocation and tracking

## Future Enhancements

### Short Term (1-2 months)
- [ ] Implement SSL/TLS certificates (Let's Encrypt)
- [ ] Add application health checks and monitoring
- [ ] Create staging environment
- [ ] Implement log aggregation (ELK stack)

### Medium Term (3-6 months)
- [ ] Migrate to container-based deployment (Docker + ECS)
- [ ] Implement blue-green deployment strategy
- [ ] Add comprehensive test suite
- [ ] Set up disaster recovery procedures

### Long Term (6+ months)
- [ ] Kubernetes migration for microservices architecture
- [ ] Multi-region deployment for global availability
- [ ] Advanced security scanning and compliance
- [ ] Machine learning-based performance optimization

## Conclusion

This EpicBook deployment project successfully demonstrates Infrastructure as Code principles using Terraform and Ansible. The combination provides:

- **Repeatability**: Consistent deployments across environments
- **Scalability**: Modular design supports growth
- **Maintainability**: Clear code structure and documentation
- **Security**: Best practices for cloud deployments

The project serves as a solid foundation for production-ready applications with proper CI/CD integration and monitoring solutions.

---

**Project Duration**: 2 weeks
**Team Size**: 1 developer
**Technologies**: Terraform, Ansible, AWS, Node.js, RDS MySQL, Nginx
**Deployment Target**: AWS ap-southeast-1 region
