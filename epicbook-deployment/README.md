# EpicBook App Deployment using Terraform + Ansible

Automated deployment of the EpicBook Node.js application on AWS EC2 using Terraform for infrastructure provisioning and Ansible for application configuration.

## Architecture

- **Infrastructure**: AWS VPC, EC2 instance, Security Groups
- **Application**: Node.js EpicBook app with MariaDB database
- **Web Server**: Nginx reverse proxy
- **Region**: ap-southeast-1 (Singapore)

## Prerequisites

- AWS CLI configured with appropriate credentials
- Terraform >= 1.0
- Ansible >= 2.9
- SSH key pair (`~/.ssh/id_rsa`)

## Quick Start

### 1. Deploy Infrastructure

```bash
cd terraform
terraform init
terraform plan
terraform apply -auto-approve
```

This creates:

- VPC with public subnet (10.0.0.0/16)
- EC2 instance (t2.micro, Amazon Linux 2023)
- Security groups (SSH, HTTP, HTTPS)
- Auto-generates Ansible inventory

### 2. Deploy Application

```bash
cd ../ansible
ansible-playbook -i inventory.ini site.yaml
```

This configures:

- System packages (Node.js, MariaDB, Nginx)
- EpicBook application from GitHub
- Database schema and seed data
- Nginx reverse proxy
- Systemd services

## Configuration

### Terraform Variables

- `prefix`: Resource naming prefix (default: "epkbk")
- `instance_type`: EC2 instance type (default: "t2.micro")
- `ami_id`: Amazon Linux 2023 AMI
- `ssh_key_pair`: SSH key configuration

### Ansible Variables

- `project_repo_url`: https://github.com/pravinmishraaws/theepicbook
- `db_name`: bookstore
- `db_user`: theepicbook
- Application runs on port 8080, proxied via Nginx on port 80

## Access

After deployment, access the application at:

```sh
http://<EC2_PUBLIC_IP>
```

## Cleanup

```bash
cd terraform
terraform destroy
```

## File Structure

```sh
â”œâ”€â”€ README.md
â”œâ”€â”€ ansible
â”‚   â”œâ”€â”€ ansible.cfg
â”‚   â”œâ”€â”€ inventory.ini
â”‚   â”œâ”€â”€ site.yaml
â”‚   â”œâ”€â”€ inventories
â”‚   â”‚   â””â”€â”€ inventory.ini
â”‚   â”œâ”€â”€ roles
â”‚   â”‚   â”œâ”€â”€ app
â”‚   â”‚   â”‚   â”œâ”€â”€ handlers
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ main.yaml
â”‚   â”‚   â”‚   â”œâ”€â”€ tasks
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ main.yaml
â”‚   â”‚   â”‚   â””â”€â”€ templates
â”‚   â”‚   â”‚       â””â”€â”€ my.cnf.j2
â”‚   â”‚   â”œâ”€â”€ database
â”‚   â”‚   â”‚   â””â”€â”€ tasks
â”‚   â”‚   â”‚       â””â”€â”€ main.yaml
â”‚   â”‚   â”œâ”€â”€ epicbook
â”‚   â”‚   â”‚   â”œâ”€â”€ handlers
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ main.yaml
â”‚   â”‚   â”‚   â”œâ”€â”€ tasks
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ main.yaml
â”‚   â”‚   â”‚   â””â”€â”€ templates
â”‚   â”‚   â”‚       â”œâ”€â”€ config.json.j2
â”‚   â”‚   â”‚       â””â”€â”€ epicbook.service.j2
â”‚   â”‚   â””â”€â”€ nginx
â”‚   â”‚       â”œâ”€â”€ handlers
â”‚   â”‚       â”‚   â””â”€â”€ main.yaml
â”‚   â”‚       â”œâ”€â”€ tasks
â”‚   â”‚       â”‚   â””â”€â”€ main.yaml
â”‚   â”‚       â””â”€â”€ templates
â”‚   â”‚           â””â”€â”€ nginx.conf.j2
â”‚   â””â”€â”€ vars
â”‚       â”œâ”€â”€ env.yml
â”‚       â””â”€â”€ vault.yml
â””â”€â”€ terraform
    â”œâ”€â”€ backend.tf
    â”œâ”€â”€ main.tf
    â”œâ”€â”€ outputs.tf
    â”œâ”€â”€ provider.tf
    â”œâ”€â”€ variables.tf
    â””â”€â”€ modules
        â”œâ”€â”€ instance
        â”‚   â”œâ”€â”€ main.tf
        â”‚   â”œâ”€â”€ outputs.tf
        â”‚   â””â”€â”€ variables.tf
        â””â”€â”€ vpc
            â”œâ”€â”€ main.tf
            â”œâ”€â”€ outputs.tf
            â””â”€â”€ variables.tf
```

## Project Structure Overview

### ğŸ—ï¸ Terraform Directory (Infrastructure Layer)

#### Core Files

- **`main.tf`** - Primary infrastructure definitions (VPC, EC2, security groups)
- **`variables.tf`** - Input parameters (instance type, AMI ID, region)
- **`outputs.tf`** - Export values (public IP, instance ID) for Ansible
- **`provider.tf`** - AWS provider configuration and version constraints
- **`backend.tf`** - Remote state storage (S3 bucket, DynamoDB locking)

#### Modules (Reusable Components)

- **`modules/vpc/`** - Network infrastructure (VPC, subnets, internet gateway)
- **`modules/instance/`** - EC2 instance with security groups and key pairs

**Why modules?** Promotes reusability, testing, and maintainability across environments.

### ğŸ”§ Ansible Directory (Configuration Layer)

#### Core Files

- **`ansible.cfg`** - Ansible behavior settings (SSH options, inventory path)
- **`site.yaml`** - Main playbook orchestrating all roles
- **`inventory.ini`** - Target hosts (auto-generated by Terraform)

#### Roles (Service Components)

Each role handles a specific service:

- **`app/`** - System packages and basic server setup
- **`database/`** - MariaDB installation and configuration
- **`epicbook/`** - Node.js application deployment
- **`nginx/`** - Web server and reverse proxy setup

#### Role Structure

- **`tasks/main.yaml`** - Execution steps (install, configure, start)
- **`handlers/main.yaml`** - Event-driven actions (restart services)
- **`templates/`** - Configuration file templates (Jinja2)

#### Variables

- **`vars/env.yml`** - Environment-specific settings
- **`vars/vault.yml`** - Encrypted secrets (database passwords)

### ğŸ”„ Why This Structure?

#### Separation of Concerns

- **Terraform** = Infrastructure state management
- **Ansible** = Configuration and deployment

#### Scalability

- Modular design allows environment replication
- Role-based structure enables service reuse

#### Maintainability

- Clear file organization
- Template-driven configuration
- Version-controlled infrastructure

#### Security

- Encrypted secrets with Ansible Vault
- SSH key-based authentication
- Least privilege security groups

This structure follows DevOps best practices, making the deployment process repeatable, scalable, and maintainable across different environments.
